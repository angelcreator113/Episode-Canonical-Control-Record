#!/bin/bash
set -x

# Deployment lock to prevent concurrent deployments
LOCK_FILE="/tmp/episode-metadata-deploy.lock"
if [ -f "$LOCK_FILE" ]; then
  LOCK_PID=$(cat "$LOCK_FILE")
  if ps -p "$LOCK_PID" > /dev/null 2>&1; then
    echo "‚ö†Ô∏è  Another deployment is in progress (PID: $LOCK_PID)"
    echo "Waiting up to 5 minutes for it to complete..."
    for i in {1..60}; do
      sleep 5
      if [ ! -f "$LOCK_FILE" ] || ! ps -p "$LOCK_PID" > /dev/null 2>&1; then
        echo "‚úì Previous deployment completed"
        break
      fi
      if [ $i -eq 60 ]; then
        echo "‚ùå Previous deployment still running after 5 minutes, removing stale lock"
        rm -f "$LOCK_FILE"
      fi
    done
  else
    echo "‚úì Removing stale lock file"
    rm -f "$LOCK_FILE"
  fi
fi

echo $$ > "$LOCK_FILE"
trap "rm -f $LOCK_FILE" EXIT

# Ensure we have a clean repository setup
if [ ! -d ~/episode-metadata/.git ]; then
  echo "üìÅ Setting up fresh episode-metadata repository..."
  rm -rf ~/episode-metadata
  mkdir -p ~/episode-metadata
  cd ~/episode-metadata
  git clone https://github.com/angelcreator113/Episode-Canonical-Control-Record.git .
  echo "‚úì Repository cloned successfully"
else
  echo "üìÅ Using existing repository..."
  cd ~/episode-metadata
  # Reset any local changes
  git reset --hard HEAD
  git clean -fd
  echo "‚úì Repository cleaned"
fi

echo "üîç Checking Node.js version..."
node --version || echo "Node not found"
export NVM_DIR="$HOME/.nvm"
if [ -s "$NVM_DIR/nvm.sh" ]; then
  source "$NVM_DIR/nvm.sh"
fi

if ! node --version 2>/dev/null | grep -q "v20"; then
  echo "üì¶ Installing Node.js 20 via nvm..."
  if [ ! -d "$NVM_DIR" ]; then
    echo "Installing nvm..."
    curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
    export NVM_DIR="$HOME/.nvm"
    source "$NVM_DIR/nvm.sh"
  fi
  nvm install 20
  nvm use 20
  nvm alias default 20
  echo "‚úì Node.js 20 installed"
else
  echo "‚úì Node.js 20 detected, ensuring it's active..."
  nvm use 20 2>/dev/null || true
  nvm alias default 20  # Make sure it's the default
fi

echo "Active Node version:"
node --version
npm --version
which node

# Verify Node 20 binary exists
if [ -f ~/.nvm/versions/node/v20.20.0/bin/node ]; then
  echo "‚úì Node 20 binary confirmed at: ~/.nvm/versions/node/v20.20.0/bin/node"
  ~/.nvm/versions/node/v20.20.0/bin/node --version
else
  echo "‚ö†Ô∏è Node 20 binary not at expected location, listing available versions:"
  ls -la ~/.nvm/versions/node/
fi

echo "üóëÔ∏è Removing old directories..."
rm -rf ~/Episode-Canonical-Control-Record 2>/dev/null || true

echo "üõë Stopping all Node processes..."
pkill -9 node || true
pm2 kill || true

echo "üì¶ Fetching latest code..."
git fetch origin
git checkout dev
git pull origin dev

# ============================================================================
# CREATE .ENV FILE FROM GITHUB SECRETS
# ============================================================================
echo "üìù Creating .env file from environment variables..."

# Check if required environment variables are set
REQUIRED_VARS="DATABASE_URL AWS_REGION AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY COGNITO_USER_POOL_ID COGNITO_CLIENT_ID JWT_SECRET"
MISSING_VARS=""

for var in $REQUIRED_VARS; do
  if [ -z "${!var}" ]; then
    MISSING_VARS="$MISSING_VARS $var"
  fi
done

if [ -n "$MISSING_VARS" ]; then
  echo "‚ùå ERROR: Missing required environment variables:$MISSING_VARS"
  echo "These should be set in GitHub Actions secrets"
  exit 1
fi

# Create .env file
cat > .env << EOF
# =============================================================================
# ENVIRONMENT CONFIGURATION - Generated by deployment script
# =============================================================================

NODE_ENV=production
PORT=3002

# Database
DATABASE_URL=$DATABASE_URL
DB_SSL=true

# AWS Configuration
AWS_REGION=$AWS_REGION
AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID
AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY

# S3 Storage
S3_PRIMARY_BUCKET=${S3_PRIMARY_BUCKET:-episode-metadata-storage-dev}
S3_THUMBNAILS_BUCKET=${S3_THUMBNAILS_BUCKET:-episode-metadata-thumbnails-dev}

# SQS Queue
SQS_THUMBNAIL_QUEUE_URL=${SQS_THUMBNAIL_QUEUE_URL:-}

# Cognito Authentication
COGNITO_USER_POOL_ID=$COGNITO_USER_POOL_ID
COGNITO_CLIENT_ID=$COGNITO_CLIENT_ID
COGNITO_REGION=${COGNITO_REGION:-$AWS_REGION}

# JWT
JWT_SECRET=$JWT_SECRET

# Application
LOG_LEVEL=${LOG_LEVEL:-info}
EOF

echo "‚úÖ .env file created successfully"
echo "Configuration loaded:"
echo "  ‚Ä¢ DATABASE_URL: $(echo $DATABASE_URL | sed 's/:[^:]*@/:***@/')"
echo "  ‚Ä¢ AWS_REGION: $AWS_REGION"
echo "  ‚Ä¢ COGNITO_USER_POOL_ID: $COGNITO_USER_POOL_ID"
echo "  ‚Ä¢ S3_PRIMARY_BUCKET: ${S3_PRIMARY_BUCKET:-episode-metadata-storage-dev}"

echo "üîç Verifying file content after git pull..."
echo "Current commit:"
git log -1 --oneline
echo ""
echo "First 35 lines of src/app.js:"
head -35 src/app.js
echo ""
echo "PM2 ecosystem config script path:"
grep "script:" ecosystem.config.js
echo ""

echo "ÔøΩÔ∏è Clearing Node.js cache and node_modules..."
rm -rf node_modules package-lock.json
rm -rf ~/.pm2/dump.pm2

echo "üì¶ Installing backend dependencies (fresh install)..."
npm install

echo "üñºÔ∏è Installing Sharp with platform-specific prebuilt binaries..."
# Use prebuilt Sharp binaries instead of compilation to avoid issues
npm install --arch=x64 --platform=linux sharp
echo "‚úÖ Sharp installed successfully"

echo "üé® Building frontend..."
cd frontend

echo "üóëÔ∏è Aggressively clearing all Vite/build caches..."
# Remove dist and ALL possible Vite cache locations
rm -rf dist
rm -rf .vite
rm -rf node_modules/.vite
rm -rf node_modules/.cache
rm -rf .cache
rm -rf .env.local .env.production.local .env.development.local
rm -rf ~/.cache/vite 2>/dev/null || true
rm -rf ~/.pm2/logs/* ~/.pm2/.pm2 2>/dev/null || true

# Also clear any Vite temp files
find . -name ".vite" -type d -exec rm -rf {} + 2>/dev/null || true
find node_modules -name ".cache" -type d -exec rm -rf {} + 2>/dev/null || true

echo "‚úì All Vite caches cleared"
echo "Verifying dist was deleted:"
ls -la dist/ 2>&1 || echo "‚úì dist not found (good)"

echo "Using .env.production for build (VITE_API_BASE should be empty):"
cat .env.production || echo "No .env.production found"

echo "üì¶ Installing/updating frontend dependencies..."
npm ci 2>&1 | tee npm-install.log
NPM_EXIT_CODE=${PIPESTATUS[0]}
if [ $NPM_EXIT_CODE -ne 0 ]; then
  echo "‚ö†Ô∏è npm ci failed with exit code $NPM_EXIT_CODE, trying npm install instead..."
  cat npm-install.log | tail -50
  npm install 2>&1 | tail -30
fi

echo "üî® Running FRESH Vite build (caches already cleared)..."
# Limit Node memory to prevent OOM on small EC2 instances
NODE_OPTIONS="--max-old-space-size=1536" NODE_ENV=production npm run build 2>&1 | tee build.log
BUILD_EXIT_CODE=${PIPESTATUS[0]}

if [ $BUILD_EXIT_CODE -ne 0 ]; then
  echo "‚ùå Frontend build failed with exit code $BUILD_EXIT_CODE"
  echo "Full build log:"
  cat build.log
  exit 1
fi

if [ ! -d "dist" ]; then
  echo "‚ùå Frontend build failed - dist directory not created"
  echo "Build log:"
  cat build.log
  exit 1
fi

if [ ! -f "dist/index.html" ]; then
  echo "‚ùå Frontend build incomplete - index.html not found in dist"
  echo "Dist contents:"
  ls -la dist/
  exit 1
fi

echo "‚úì Frontend built successfully"
echo "Dist contents:"
ls -lh dist/
if [ -d "dist/assets" ]; then
  echo "ALL asset files:"
  ls -lh dist/assets/
  echo "File hashes:"
  md5sum dist/assets/*.js
fi
echo "Checking index.html:"
cat dist/index.html
echo "Verifying index.html has script tags:"
grep -o '<script[^>]*src="[^"]*"' dist/index.html || echo "‚ö†Ô∏è No script tags found in index.html!"

# CRITICAL: Verify JS files referenced in index.html actually exist
echo "üîç CRITICAL: Verifying dist/assets files match index.html references..."
if [ -f "dist/index.html" ]; then
  HTML_JS_REFS=$(grep -o 'src="/assets/[^"]*\.js"' dist/index.html | sed 's|src="||' | sed 's|"||' | sed 's|/assets/||')
  
  echo "JS files referenced in index.html:"
  echo "$HTML_JS_REFS"
  echo ""
  
  if [ -n "$HTML_JS_REFS" ]; then
    MISSING_FILES=0
    for ref in $HTML_JS_REFS; do
      if [ -f "dist/assets/$ref" ]; then
        echo "  ‚úì Found: dist/assets/$ref"
      else
        echo "  ‚ùå MISSING: dist/assets/$ref"
        MISSING_FILES=$((MISSING_FILES + 1))
      fi
    done
    
    if [ $MISSING_FILES -gt 0 ]; then
      echo "‚ùå CRITICAL: $MISSING_FILES JS file(s) referenced in index.html are missing from dist/assets!"
      echo "Build is corrupted. Aborting deployment."
      exit 1
    fi
    echo "‚úÖ All JS references verified - files exist in dist/assets!"
  else
    echo "‚ö†Ô∏è No JS file references found in index.html (might be inline or build issue)"
  fi
else
  echo "‚ùå index.html not found!"
  exit 1
fi

# üì¶ Copy frontend build to root dist/ for Express to serve
echo "üì¶ Copying frontend build to root dist directory..."
cd ..
rm -rf dist/
cp -r frontend/dist dist/
echo "‚úÖ Frontend copied to: $(pwd)/dist/"

cd .

echo "üóÑÔ∏è Running migrations..."
source "$NVM_DIR/nvm.sh" 2>/dev/null || true
nvm use 20 2>/dev/null || true

# ============================================================================
# DATABASE CONFIGURATION - Use environment variables from GitHub Secrets
# ============================================================================
# These should be set by the GitHub Actions workflow
if [ -z "$DATABASE_URL" ]; then
  echo "‚ùå ERROR: DATABASE_URL environment variable not set"
  echo "This should be provided by GitHub Actions secrets"
  exit 1
fi

export DB_SSL="true"
export NODE_TLS_REJECT_UNAUTHORIZED="0"

echo "‚úÖ Database configuration loaded from environment variables"
echo "Database host: $(echo $DATABASE_URL | sed 's/.*@\([^:]*\):.*/\1/')"

# ============================================================================
# RUN SEQUELIZE MIGRATIONS - Let Sequelize handle schema
# ============================================================================
echo "Running Sequelize migrations..."
npm run migrate:up 2>&1 | tee migration.log
MIGRATION_STATUS=$?

if [ $MIGRATION_STATUS -ne 0 ]; then
  echo "‚ö†Ô∏è Migration failed with status $MIGRATION_STATUS"
  cat migration.log | tail -50
  echo "Continuing deployment - app will handle schema sync..."
else
  echo "‚úÖ Migrations completed successfully"
fi

if ! command -v pm2 &> /dev/null; then
  npm install -g pm2
fi

echo "üîÑ Stopping and restarting application..."
pm2 stop all || true
pm2 delete all || true
sleep 2
pkill -f "node.*app.js" || true
pkill -f "node.*episode" || true
sleep 1
            
mkdir -p ~/episode-metadata/logs
rm -f ~/episode-metadata/logs/*.log
pm2 flush || true
cd ~/episode-metadata

# Force PM2 to use Node 20 by updating PM2 with the correct Node version
echo "üîÑ Updating PM2 to use Node 20..."
pm2 update
pm2 kill || true  # Kill PM2 daemon to force fresh start with new Node
sleep 2

if [ ! -f ecosystem.config.js ]; then
  echo "‚ùå ERROR: ecosystem.config.js not found!"
  ls -la
  exit 1
fi

echo "üìã Ecosystem config found, contents:"
head -20 ecosystem.config.js

echo "üß™ Testing database connection..."
node -e "
const { Sequelize } = require('sequelize');
if (!process.env.DATABASE_URL) {
  console.error('‚ùå DATABASE_URL not set');
  process.exit(1);
}
const sequelize = new Sequelize(process.env.DATABASE_URL, {
  dialectOptions: { ssl: { require: true, rejectUnauthorized: false } },
  logging: false
});
sequelize.authenticate()
  .then(() => { console.log('‚úÖ Database connection successful'); process.exit(0); })
  .catch(err => { console.error('‚ùå Database connection failed:', err.message); process.exit(1); });
" || echo "‚ö†Ô∏è Database connection test failed"

echo "üß™ Testing if Node can load app.js..."
cd ~/episode-metadata
node --check src/app.js || echo "‚ùå Syntax error in app.js!"
echo "üß™ Testing if app starts at all..."
timeout 5 node src/app.js 2>&1 | head -20 || echo "App failed to start"

echo "üîç Final Node version verification before PM2 start:"
echo "Shell node: $(node --version)"
echo "Which node: $(which node)"
echo "PATH: $PATH"

echo "üìã Starting PM2 with ecosystem config..."
# Use full path to node from nvm to force correct version
PM2_HOME=/home/ubuntu/.pm2 pm2 start ecosystem.config.js --update-env 2>&1 | tee pm2-start.log

if [ $? -ne 0 ]; then
  echo "‚ùå PM2 start failed! Output:"
  cat pm2-start.log
  cat ~/episode-metadata/logs/error.log 2>/dev/null || echo "No error log"
  exit 1
fi

pm2 save --force
sleep 3
pm2 status

# Check if app is online with retries
MAX_PM2_RETRIES=5
for attempt in $(seq 1 $MAX_PM2_RETRIES); do
  echo "üîç Checking if app is online (attempt $attempt/$MAX_PM2_RETRIES)..."
  if pm2 list | grep -q "episode-api.*online"; then
    echo "‚úÖ App is online!"
    break
  fi
  
  if [ $attempt -lt $MAX_PM2_RETRIES ]; then
    echo "‚ö†Ô∏è App not online yet, waiting 3 seconds..."
    sleep 3
  else
    echo "‚ùå App failed to come online after $MAX_PM2_RETRIES attempts"
    pm2 logs episode-api --lines 50 --nostream
    exit 1
  fi
done

echo "üîç CRITICAL: Verifying PM2 is actually using Node 20:"
pm2 show episode-api | grep -E "node.js version|interpreter"
PM2_NODE_VERSION=$(pm2 show episode-api | grep "node.js version" | awk '{print $5}')
echo "PM2 detected Node version: $PM2_NODE_VERSION"
if [[ "$PM2_NODE_VERSION" == "20."* ]]; then
  echo "‚úÖ PM2 is correctly using Node 20"
else
  echo "‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è WARNING: PM2 is using Node $PM2_NODE_VERSION instead of Node 20!"
  echo "This may cause runtime issues!"
fi

echo "üîç Verifying PM2 environment variables:"
pm2 env 0 | grep -E "DATABASE_URL|NODE_ENV|PORT|DB_SSL" || echo "‚ö†Ô∏è Env vars not found"
echo "üß™ Testing if app is listening on port 3002..."
sleep 2
ss -tlnp 2>/dev/null | grep 3002 || lsof -i :3002 || echo "‚ö†Ô∏è Nothing listening on port 3002 (but this is normal if curl works)"
echo "üß™ Testing health endpoint..."
curl -v http://localhost:3002/health 2>&1 | head -30 || echo "‚ö†Ô∏è Health check failed"
echo "üß™ Testing root endpoint..."
curl -I http://localhost:3002/ 2>&1 | head -10 || echo "‚ö†Ô∏è Root endpoint failed"
echo "üîç Testing app locally:"
sleep 3
HEALTH_RESPONSE=$(curl -s -w "\n%{http_code}" http://localhost:3002/health)
HTTP_CODE=$(echo "$HEALTH_RESPONSE" | tail -n1)
if [[ "$HTTP_CODE" == "200" ]]; then
  echo "‚úÖ Health check successful (HTTP $HTTP_CODE)"
else
  echo "‚ö†Ô∏è Health check returned HTTP $HTTP_CODE"
fi
echo "üìã Checking logs for errors:"
sleep 2
pm2 logs episode-api --lines 50 --nostream || true
echo "üîç Checking app startup errors:"
cat ~/episode-metadata/logs/error.log 2>/dev/null | tail -50 || echo "No error log yet"
echo "ÔøΩ Diagnosing Node version issue:"
echo "NVM default:"
nvm current
echo "Which node:"
which node
node --version
echo "Node 20 binary check:"
if [ -f /home/ubuntu/.nvm/versions/node/v20.20.0/bin/node ]; then
    /home/ubuntu/.nvm/versions/node/v20.20.0/bin/node --version
else
    echo "‚ùå Node 20 binary missing, reinstalling..."
    nvm install 20
    nvm alias default 20
fi

echo "ÔøΩüìã Checking PM2 environment:"
pm2 show episode-api || true
echo "‚úÖ Deployed!"
echo "üìã Build info:"
git log -1 --oneline
ls -lh frontend/dist/assets/*.js | head -3
echo "üîç Verifying what the app is serving:"
sleep 3
curl -s http://localhost:3002/ | grep -o 'index-[^"]*\.js' || echo "Pattern not found in localhost response"
echo "üîç Searching for ALL dist folders and old index files:"
find ~ -name "dist" -type d 2>/dev/null | head -10
find ~ -name "index-2tx_xbRM.js" 2>/dev/null || echo "Old file not found"
find ~ -name "index.html" -path "*/dist/*" -exec grep -l "index-2tx_xbRM" {} \; 2>/dev/null || echo "No old index.html found"
